Using Code Generators
=====================

Development of machine learning algorithms using Jubatus framework starts with writing an IDL (RPC interface definition).
By using two code generator - ``jenerator`` (bundled tool with Jubatus) and ``mpidl`` (from MessagePack-IDL) - you can generate each component (server, keeper, client for each language) from the IDL.
By using these generators, framework users don't need to focus on things other than implementing algorithms.

Flow of Development
-------------------

#. Define RPC interfaces that the service should have using IDL.
#. Generate codes for server and keeper with ``jenerator`` from IDL.
#. Generate data structures and client with ``mpidl`` from IDL.
#. Convert the output of ``mpidl`` with ``mpidlconv``.
#. Implement codes of interface of user-defined class and (if necessary) mix operation.

Use the `skeleton project <https://github.com/jubatus/jubatus-service-skelton>`_ to get started.

Why We Use IDL
--------------

First, there must exist same definitions in six C++ source files every time we add new learning algorithm, that is, header and implementation of client, header and implementation of keeper and header and implementation of server.
This would lead to a "hotbed" of bugs every time we had changed the API.

By using IDL, users can create system through the flow above.
Currenly all algorithms (recommener, classifier, regression, stat and graph) defines its interface with ``jenerator``.

Composition of Files
--------------------

Machine learning system that uses Jubatus framework consists of the following files (where *NAME* is a name of the service).

- NAME_serv.cpp: Implementation of the server (edit template generated by ``jenerator``)
- NAME_serv.hpp: Header file for ``NAME_serv.cpp`` (edit template generated by ``jenerator``)
- NAME_server.hpp: Parent class for the ``NAME_impl_`` class to register RPC methods (automatically generated by ``mpidl``)
- NAME_impl.cpp: ``main`` function and RPC interface definition for the server (automatically generated by ``jenerator``)
- NAME_keeper.cpp: Implementation of the keeper (automatically generated by ``jenerator``)
- NAME_client.hpp: Implementation of the client (automatically generated by ``mpidl``)
- NAME_types.hpp: Structures and type information (automatically generated by ``mpidl``; shared among server/client/keeper)

``jenerator``: The Code Generator
---------------------------------

The RPC interface is defined with `MessagePack-IDL <https://github.com/msgpack/msgpack-haskell/blob/master/msgpack-idl/Specification.md>`_.
Aside from MessagePack-IDL's original syntax, we must add annotations for each method of RPC service in order to generate Jubatus servers and keepers.

Annotations are interpreted by our code generator, called ``jenerator``, but they are ignored as comments by MessagePack-IDL.
Therefore, we can generate each client with same interface by MessagePack-IDL.

Syntax of annotations for each methods is as follows.

- Each method must have 3 annotations, each of them starts with ``#@``, that specifies "routing", "lock type" and "aggregation method" in order.

- The "routing" annotation defines how Keeper proxy requests.
  Three methods (``cht``, ``broadcast`` or ``random``) are available so that we can cover distribution methods used in typical machine learning tasks.

  - ``cht`` means that the request is distributed by using Consistent Hashing.
    Methods annotated with ``cht`` must take 2 arguments at least.
    The first argument is a string that represents a cluster name, and the second is a string that is used as a key for consistent hashing.
    Replication level of updated data is 2 by default.
    You can change the replication level by specifying like ``#@cht(1)``.
  - ``broadcast`` means that the request will be broadcasted to all servers in the cluster.
  - ``random`` means that the request will be proxied to one randomly-chosen server in the cluster.

- The "lock type" annotation defines read/write of request, and value must be one of ``analysis``, ``update`` or ``nolock``.

  - When using ``analysis``, data is locked in server with read lock and is accessible by multiple thread simultaneously.
  - When using ``update``, data is locked with write lock, so that we can safely update the data.
  - When using ``nolock``, no locks are aquired in the server.

- The "aggregation" annotation defines how to aggrate the results of API call from multiple servers.
  Available aggregators are written in `aggregators.hpp <https://github.com/jubatus/jubatus/blob/master/src/framework/aggregators.hpp>`_.

``void`` type cannot be used as the return type of methods.
If the return value is not needed, you must add meaningless type such as ``int`` or ``bool``.

Here is a example of MessagePack-IDL with annotation.

.. code-block:: c++

  message entry {
    0: string key
    1: string value
    2: int version
  }

  service kvs {
    #@cht(2) #@update #@all_and
    int put(0: string name, 1: string key, 2: string value)

    #@cht(2) #@analysis #@pass
    entry get(0: string name, 1: string key)

    #@cht(2) #@update #@all_and
    int del(0: string name, 1: string key, 2: int version)

    #@broadcast #@update #@all_and
    int clear(0: string name)

    #@broadcast #@analysis #@merge
    map<string, map<string, string> > get_status(0: string name)

    #@broadcast #@update #@all_and
    bool save(0: string name, 1: string id)

    #@broadcast #@update #@all_and
    bool load(0: string name, 1: string id)
  }

``get_status``, ``save`` and ``load`` methods are required to satisfy the common interface specification of Jubatus servers.

Building ``jenerator``
~~~~~~~~~~~~~~~~~~~~~~

You need OCaml and OMake to build ``jenerator``.

::

  $ cd jubatus/tools/generator
  $ omake
  $ sudo omake install

Hint: If you're using Ubuntu systems, OCaml (``ocaml-native-compilers``) and OMake (``omake``) are both available as a binary package.

Generating Server/Keeper from IDL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose the name of the example above is a file ``kvs.idl``, we can generate servers and keepers in the following manner.

::

  $ jenerator kvs.idl -o . -t

Four files, ``kvs_impl.cpp`` (server), ``kvs_keeper.cpp`` (keeper), and ``kvs_serv.tmpl.{cpp,hpp}`` (template of implementation of server) will be generated.

See :ref:`jenerator` for the detailed usage of ``jenerator``.

Implementing Server
-------------------

``kvs_impl.cpp`` constructs a server instance by using class ``kvs_serv``.
You need to define the class in ``kvs_serv.hpp`` and ``kvs_serv.cpp``.
You can use templates (``kvs_serv.tmpl.{cpp,hpp}``) generated by ``jenerator``.

``main`` function is implemented in ``kvs_impl.cpp``, so users don't have to implement it.
Command line options are the same among all servers using Jubatus framework.
The options can be referenced with ``--help`` option.

Mixable Class
~~~~~~~~~~~~~

TBD.

Implementing Keeper
-------------------

You have nothing to implement; just compile ``kvs_keeper.cpp``, generated by ``jenerator``, and you will get keeper.

``kvs_keeper.cpp`` only has ``main`` function, that registers functor for each RPC method that proxies requests and aggregates responses.
